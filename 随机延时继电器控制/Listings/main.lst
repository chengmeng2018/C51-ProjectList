C51 COMPILER V9.60.0.0   MAIN                                                              05/08/2020 23:23:28 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OMF2 OPTIMIZE(8,SPEED) BROWSE DEBUG PRINT(.\Listings\main.lst) TA
                    -BS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          //晶振频率请统一保持 12Mhz
   2          
   3          #include <STC8G.H>
   4          
   5          #include "motor.h"//电机驱动
   6          #include "DIG4201.h"//双位数码管驱动
   7          #include "keyBoard.h"//键盘驱动
   8          #include "IAP_EEPROM.h"//
   9          #include "Clock_T2.h"//时钟驱动
  10          #include "DeTime.h"//延时控制驱动
  11          #include "uartT1.h"
  12          sbit GPIO_Ir=P5^4;
  13          
  14          char Ir_Flag;//红外是否有信号标志位
  15          char RunFlag;//是否运行标志位
  16          char workMode=0;
  17          tmTypedef subtm;
  18          tmTypedef SleepTm,SleepLastTm;
  19          //红外组件模块
  20          static tmTypedef  Lasttm;
  21          char SleepHour=0,sleepOk=0;
  22          void ReadAllData();
  23          void WriteAllData();
  24          void WorkSet(char val,KeyState keymode);
  25          void InitIr();
  26          
  27          void SetRunFlag(char enb);
  28          void main()
  29          {
  30   1          static tmTypedef  Lasttm;
  31   1          DigInit();//P1 P3.6 P3.7
  32   1          InitKeyboard();
  33   1          ClockT2_Init();//Use interrupt 12
  34   1          InitIr();
  35   1          ReadAllData();//读取掉电前的数据
  36   1          Lasttm=GetClock();
  37   1          Setdata(m_DeTimeData.CurVal);
  38   1          while(1)
  39   1          {
  40   2              DigDisplay();
  41   2              {
  42   3                  //按键操作
  43   3                  static KeyStruct keynum;
  44   3                  static tmTypedef  KeyDownLasttm;
  45   3                  static tmTypedef  Keysubtm= {3}; //解决长按下的信号获取频率
  46   3                  KeyState keyrec;
  47   3                  keyrec=key_scan(&keynum);
  48   3                  if(keyrec==KeyFallEdge )
  49   3                  {
  50   4                      WorkSet(keynum.Value,KeyFallEdge);
  51   4                      KeyDownLasttm=  GetClock();
  52   4                  }
  53   3                  else if(keyrec ==KeyDown &&subTime(&KeyDownLasttm,&Keysubtm))
  54   3                  {
C51 COMPILER V9.60.0.0   MAIN                                                              05/08/2020 23:23:28 PAGE 2   

  55   4                      WorkSet(keynum.Value,keyrec);
  56   4                  }
  57   3              }
  58   2              {
  59   3                  //定时关机组件
  60   3                  if(SleepHour!=0 &&RunFlag==1)
  61   3                  {
  62   4                      if(subTime(&SleepLastTm,&SleepTm))
  63   4                      {
  64   5                          SleepLastTm=GetClock();
  65   5                          sleepOk=1;
  66   5                          RunFlag=0;
  67   5                          run(0);
  68   5                          SetDataRaw(0xFF,0);
  69   5                          SetDataRaw(0xFF,1);
  70   5                      }
  71   4                  }
  72   3              }
  73   2              {
  74   3                  //红外组件模块
  75   3                  if(RunFlag==1)
  76   3                  {
  77   4                      switch (Ir_Flag)
  78   4                      {
  79   5                      case 0x00://获取红外信号
  80   5                          if(GPIO_Ir)
  81   5                          {//寻找低电平信号
  82   6                              Lasttm= GetClock();
  83   6                              run(0);
  84   6                              Ir_Flag=0x01;
  85   6                          }
  86   5                          else
  87   5                          {
  88   6                          SetDataRaw(0xFF&~(0x40),0);
  89   6                          SetDataRaw(0xFF&~(0x40),1);
  90   6                          }
  91   5                          break;
  92   5                      case 0x01://等待度过当前延时
  93   5                          if(subTime(&Lasttm,&subtm))
  94   5                          {
  95   6                              if(m_DeTimeData.RngFlag)
  96   6                              {
  97   7                                  //tmVal的单位是1s 所以倍数放大
  98   7                                  subtm.tmVal=  getRng();//将新的种子存入CurVal
  99   7                              }
 100   6                              else
 101   6                              {
 102   7                                  subtm.tmVal=m_DeTimeData.StaticVal;
 103   7                              }
 104   6                              Ir_Flag=0x02;
 105   6                              run(1);
 106   6                          }
 107   5                          else
 108   5                          {
 109   6                              //获得倒计时时间
 110   6                              long timetmp=GetClock().tmVal-Lasttm.tmVal;
 111   6                              m_DeTimeData.CurVal=(subtm.tmVal-timetmp);
 112   6                              Setdata(m_DeTimeData.CurVal);
 113   6                          }
 114   5                          break;
 115   5                      case 0x02:
 116   5                        if(!GPIO_Ir)
C51 COMPILER V9.60.0.0   MAIN                                                              05/08/2020 23:23:28 PAGE 3   

 117   5                        {
 118   6                            Ir_Flag=0x00;
 119   6                        }
 120   5                        else
 121   5                        {
 122   6                          SetDataRaw(0xFF&~(0x01),0);
 123   6                          SetDataRaw(0xFF&~(0x01),1);               
 124   6                        }
 125   5                      break;
 126   5                      }
 127   4                  }
 128   3              }
 129   2          }
 130   1      
 131   1      }
 132          void ReadAllData()
 133          {
 134   1          char InitFlag=IapRead(Addr_Init_Flag);
 135   1          if(InitFlag==0x01)
 136   1          {
 137   2              // LoadDeTime();
 138   2              char i;
 139   2              m_DeTimeData.StaticVal=IapRead(Addr_DelayTime);
 140   2              m_DeTimeData.RngFlag=IapRead(Addr_RngFlag+0);
 141   2              m_DeTimeData.RngMax=IapRead(Addr_RngFlag+1);
 142   2              m_DeTimeData.RngMin=IapRead(Addr_RngFlag+2);
 143   2              if(m_DeTimeData.RngMax>99 ||m_DeTimeData.RngMax<0)
 144   2              {
 145   3                  m_DeTimeData.RngMax=99;
 146   3              }
 147   2              for(i=0; i<sizeof(m_DeTimeData.ss.seedData); i++)
 148   2              {
 149   3                  m_DeTimeData.ss.seedData[i]=IapRead(Addr_RngFlag+3+i);
 150   3              }
 151   2              SW_MOTO=IapRead(Addr_MotorDC);
 152   2              RunFlag=IapRead(Addr_RunFlag);
 153   2              workMode=IapRead( Addr_Workmode);
 154   2              SleepHour=IapRead(Addr_SleepHour);
 155   2              if(SleepHour!=0)
 156   2              {
 157   3                SleepTm.tmVal=SleepHour*60*60;
 158   3                SleepLastTm=GetClock();
 159   3              }
 160   2          }
 161   1          else
 162   1          {
 163   2              m_DeTimeData.StaticVal=10;
 164   2              m_DeTimeData.RngFlag=1;
 165   2              m_DeTimeData.RngMax=30;
 166   2              m_DeTimeData.RngMin=5;
 167   2              //m_DeTimeData.ss.seed
 168   2              SW_MOTO=1;
 169   2              Ir_Flag=0x00;
 170   2              RunFlag=0;
 171   2              workMode=0;
 172   2              SleepHour=0;  
 173   2          }
 174   1            if(m_DeTimeData.RngFlag)
 175   1              {
 176   2                  //tmVal的单位是1s 所以倍数放大
 177   2                  subtm.tmVal=  getRng();//将新的种子存入CurVal
 178   2              }
C51 COMPILER V9.60.0.0   MAIN                                                              05/08/2020 23:23:28 PAGE 4   

 179   1              else
 180   1              {
 181   2                  subtm.tmVal=m_DeTimeData.StaticVal;
 182   2              }
 183   1      
 184   1      }
 185          void WriteAllData()
 186          {
 187   1          char i;
 188   1          IapErase(Addr_Init_Flag);
 189   1          IapProgram(Addr_Init_Flag,0x01);
 190   1          IapProgram(Addr_DelayTime,m_DeTimeData.StaticVal);
 191   1          IapProgram(Addr_RngFlag+0,m_DeTimeData.RngFlag);
 192   1          IapProgram(Addr_RngFlag+1,m_DeTimeData.RngMax);
 193   1          IapProgram(Addr_RngFlag+2,m_DeTimeData.RngMin);
 194   1          for(i=0; i<sizeof(m_DeTimeData.ss.seedData); i++)
 195   1          {
 196   2              IapProgram(Addr_RngFlag+3+i,m_DeTimeData.ss.seedData[i]);
 197   2          }
 198   1          IapProgram(Addr_MotorDC,SW_MOTO);
 199   1          IapProgram(Addr_RunFlag,RunFlag);
 200   1          IapProgram(Addr_Workmode,workMode);
 201   1          IapProgram(Addr_SleepHour,SleepHour);
 202   1      }
 203          
 204          void InitIr()
 205          {
 206   1          //P5.4 准双向口
 207   1          P5M1 &=~(0x10);
 208   1          P5M0 &=~(0x10);
 209   1          GPIO_Ir=1;
 210   1      }
 211          void SetRunFlag(char enb)
 212          {
 213   1          RunFlag=enb>0;
 214   1         WriteAllData();
 215   1      }
 216          void WorkSet(char val,KeyState keymode)
 217          {
 218   1      #define workModeNum 5
 219   1          if(sleepOk!=0 && workMode==0x04 )
 220   1          {
 221   2              SetRunFlag(1);
 222   2              sleepOk=0;
 223   2              run(1);
 224   2              Setdata(m_DeTimeData.CurVal);
 225   2              Lasttm= GetClock();
 226   2          }
 227   1          switch(workMode)
 228   1          {
 229   2          case 0x00://启动后无操作
 230   2              switch(val)
 231   2              {
 232   3              case 0x01://Up
 233   3                  //启动
 234   3                  SetRunFlag(1);
 235   3                  Setdata(workMode*10+1);
 236   3                  break;
 237   3              case 0x02://Down
 238   3                  //停止
 239   3                  SetRunFlag(0);
 240   3                  run(0);
C51 COMPILER V9.60.0.0   MAIN                                                              05/08/2020 23:23:28 PAGE 5   

 241   3                  Setdata(workMode*10);
 242   3                  break;
 243   3              case 0x04://mode
 244   3                  workMode=(workMode+1)%workModeNum;
 245   3                  SetRunFlag(0);
 246   3                  Setdata(workMode*10);
 247   3                  SetDataRaw(0xFF,1);
 248   3                  break;
 249   3              }
 250   2              break;
 251   2          case 0x01://设置电机选项
 252   2              switch(val)
 253   2              {
 254   3              case 0x01://Up
 255   3                  SelectMotorDC(1);
 256   3                  Setdata(workMode*10+1);
 257   3                  break;
 258   3              case 0x02://Down
 259   3                  SelectMotorDC(0);
 260   3                  Setdata(workMode*10);
 261   3                  break;
 262   3              case 0x04://mode
 263   3                  workMode=(workMode+1)%workModeNum;
 264   3                  Setdata(workMode*10);
 265   3                  SetDataRaw(0xFF,1);
 266   3                  break;
 267   3              }
 268   2              break;
 269   2          case 0x02://设置工作模式 随机事件或固定时间
 270   2              switch(val)
 271   2              {
 272   3              case 0x01://Up
 273   3                  SetFlag(1);
 274   3                  Setdata(workMode*10+1);
 275   3                  break;
 276   3              case 0x02://Down
 277   3                  SetFlag(0);
 278   3                  Setdata(workMode*10);
 279   3                  break;
 280   3              case 0x04://mode
 281   3                  workMode=(workMode+1)%workModeNum;
 282   3                  Setdata(workMode*10);
 283   3                  SetDataRaw(0xFF,1);
 284   3                  break;
 285   3              }
 286   2              break;
 287   2          case 0x03://修改设定时间
 288   2              if( m_DeTimeData.RngFlag ==1)
 289   2              {
 290   3                  //如果随机时间
 291   3                  switch(val)
 292   3                  {
 293   4                  case 0x01://Up
 294   4                      OffSetMXVal(1);
 295   4                      Setdata(m_DeTimeData.RngMax);
 296   4                      break;
 297   4                  case 0x02://Down
 298   4                      OffSetMXVal(-1);
 299   4                      Setdata(m_DeTimeData.RngMax);
 300   4                      break;
 301   4                  case 0x04://mode
 302   4                      workMode=(workMode+1)%workModeNum;
C51 COMPILER V9.60.0.0   MAIN                                                              05/08/2020 23:23:28 PAGE 6   

 303   4                      Setdata(workMode*10);
 304   4                      SetDataRaw(0xFF,1);
 305   4                      break;
 306   4                  }
 307   3      
 308   3              }
 309   2              else
 310   2              {
 311   3                  switch(val)
 312   3                  {
 313   4                  case 0x01://Up
 314   4                      OffSetstVal(1);
 315   4                      Setdata(m_DeTimeData.StaticVal);
 316   4                      break;
 317   4                  case 0x02://Down
 318   4                      OffSetstVal(-1);
 319   4                      Setdata(m_DeTimeData.StaticVal);
 320   4                      break;
 321   4                  case 0x04://mode
 322   4                      workMode=0x05;
 323   4                      Setdata(workMode*10);
 324   4                      SetDataRaw(0xFF,1);
 325   4                      break;
 326   4                  }
 327   3              }
 328   2              break;
 329   2          case 0x04://修改RngMin时间
 330   2              switch(val)
 331   2              {
 332   3              case 0x01://Up
 333   3                  OffSetMNVal(1);
 334   3                  Setdata(m_DeTimeData.RngMin);
 335   3                  break;
 336   3              case 0x02://Down
 337   3                  OffSetMNVal(-1);
 338   3                  Setdata(m_DeTimeData.RngMin);
 339   3                  break;
 340   3              case 0x04://mode
 341   3                 workMode=(workMode+1)%workModeNum;
 342   3                  Setdata(workMode*10);
 343   3                  SetDataRaw(0xFF,1);
 344   3                  break;
 345   3              }
 346   2              break;
 347   2          case 0x05://设定自动停机的参数
 348   2              switch(val)
 349   2              {
 350   3              case 0x01://Up
 351   3                  SleepHour=(SleepHour+1)>99?99:(SleepHour+1);
 352   3                  Setdata(SleepHour);
 353   3                  break;
 354   3              case 0x02://Down
 355   3                  SleepHour=(SleepHour-1)<0?0:(SleepHour-1);
 356   3                  Setdata(SleepHour);
 357   3                  break;
 358   3              case 0x04://mode
 359   3                  workMode=0;
 360   3                  Setdata(workMode*10);
 361   3                  SetDataRaw(0xFF,1);
 362   3                  break;
 363   3              }
 364   2              SleepTm.tmVal=SleepHour*60*60;
C51 COMPILER V9.60.0.0   MAIN                                                              05/08/2020 23:23:28 PAGE 7   

 365   2              SleepLastTm=GetClock();
 366   2              break;
 367   2          }
 368   1          WriteAllData();
 369   1      }
*** WARNING C280 IN LINE 216 OF main.c: 'keymode': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1518    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     36       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
